// Generated by CoffeeScript 1.6.1
var Daemon, Graph, SmoothRandomGenerator, checkData, controlStatus, cookieExpiryDays, createDaemonWebSocket, createMessage, createServerWebSocket, daemonAddress, daemons, daemonws, development, error, getCookie, getDaemon, getGraph, graph_id, graphs, init, initUI, isUserLoggedIn, loginCheckSuccessful, loginCheckUnsuccessful, loginSuccessful, loginUnsuccessful, logoutError, logoutSuccessful, messages, monitoringData, notImplemented, processControl, processDaemons, processError, processHistory, processIncomingMessage, processLogin, processLoginCheck, processLogout, processMonitoring, processNotImplemented, reconnectTimerDaemon, reconnectTimerServer, reconnectTiming, sendControl, sendDaemons, sendLogin, sendLoginCheck, sendLogout, serverAddress, serverws, setCookie, simulate, simulate2, test, testIN, testOUT, testing, trySendMessage, updateDaemons, wsDaemonOnCloseHandler, wsDaemonOnErrorHandler, wsDaemonOnMessageHandler, wsDaemonOnOpenHandler, wsServerOnCloseHandler, wsServerOnErrorHandler, wsServerOnMessageHandler, wsServerOnOpenHandler,
  __hasProp = {}.hasOwnProperty;

setCookie = function(name, value, days) {
  var date, expires;
  if (days) {
    date = new Date;
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    expires = "; expires=" + date.toGMTString();
  } else {
    expires = "";
  }
  return document.cookie = name + "=" + value + expires + "; path=/";
};

getCookie = function(key) {
  var c, _i, _len, _ref;
  key = key + "=";
  _ref = document.cookie.split(';');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    c = _ref[_i];
    while (c.charAt(0) === ' ') {
      c.substring(1, c.length);
    }
    if (c.indexOf(key) === 0) {
      return c.substring(key.length, c.length);
    }
  }
  return null;
};

Daemon = (function() {

  function Daemon(params) {
    this.daemon_id = params.daemon_id;
    this.daemon_name = params.daemon_name;
    this.daemon_state = params.daemon_state;
    this.daemon_address = params.daemon_address;
    this.daemon_port = params.daemon_port;
    this.daemon_platform = params.daemon_platform;
    this.daemon_all_parameters = params.daemon_all_parameters;
    this.daemon_monitored_parameters = params.daemon_monitored_parameters;
  }

  Daemon.prototype.setDaemonProperties = function(properties) {
    var key, value, _results;
    _results = [];
    for (key in properties) {
      if (!__hasProp.call(properties, key)) continue;
      value = properties[key];
      if (key !== "daemon_id") {
        _results.push(this[key] = value);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Daemon.prototype.stop = function() {
    sendControl(this.daemon_id, "stop");
  };

  Daemon.prototype.start = function() {
    return sendControl(this.daemon_id, "start");
  };

  Daemon.prototype.monitor = function(parameter) {
    var operation;
    operation = {
      "start": [parameter]
    };
    return sendControl(this.daemon_id, operation);
  };

  Daemon.prototype.unmonitor = function(parameter) {
    var operation;
    operation = {
      "stop": [parameter]
    };
    return sendControl(this.daemon_id, operation);
  };

  return Daemon;

})();

isUserLoggedIn = false;

cookieExpiryDays = 3;

daemons = [];

loginCheckSuccessful = function() {
  return isUserLoggedIn = true;
};

loginCheckUnsuccessful = function() {
  return isUserLoggedIn = false;
};

loginSuccessful = function(session_id) {
  isUserLoggedIn = true;
  return setCookie("session_id", session_id, cookieExpiryDays);
};

loginUnsuccessful = function() {
  isUserLoggedIn = false;
  return setCookie("session_id", null, cookieExpiryDays);
};

logoutSuccessful = function() {
  isUserLoggedIn = false;
  setCookie("session_id", null, cookieExpiryDays);
  return daemons = [];
};

logoutError = function() {};

getDaemon = function(daemon_id) {
  var daemon, _i, _len;
  for (_i = 0, _len = daemons.length; _i < _len; _i++) {
    daemon = daemons[_i];
    if (daemon.daemon_id === daemon_id) {
      return daemon;
    }
  }
};

updateDaemons = function(data) {
  var daemon, daemon_id;
  daemon_id = data.daemon_id;
  daemon = getDaemon(daemon_id);
  if (daemon) {
    return daemon.setDaemonProperties(data);
  } else {
    return daemons.push(new Daemon(data));
  }
};

controlStatus = function(data) {};

monitoringData = function(data) {
  var daemon_id, graph, key, value, _results;
  daemon_id = data.daemon_id;
  data = data.data;
  _results = [];
  for (key in data) {
    if (!__hasProp.call(data, key)) continue;
    value = data[key];
    graph = getGraph(daemon_id, key);
    if (graph) {
      _results.push(graph.update(value));
    } else {
      _results.push(console.error("There is no graph associated with daemon: " + daemon_id + " for attribute: " + key));
    }
  }
  return _results;
};

processHistory = function(data) {};

notImplemented = function(data) {};

error = function(data) {};

initUI = function() {};

serverAddress = "ws://shacron.twilightparadox.com:8080/wsclient";

if (document.URL === "http://localhost:8080/") {
  serverAddress = "ws://localhost:8080/wsclient";
}

daemonAddress = null;

serverws = null;

daemonws = null;

reconnectTimerServer = null;

reconnectTimerDaemon = null;

reconnectTiming = 5000;

testing = false;

testOUT = false;

testIN = true;

development = true;

$(document).ready(function() {
  return init();
});

init = function() {
  serverws = createServerWebSocket(serverAddress);
  return initUI();
};

messages = {
  out: {
    loginCheck: {
      data: ["session_id"]
    },
    login: {
      data: ["username", "password"]
    },
    logout: {
      data: []
    },
    daemons: {
      data: []
    },
    control: {
      data: ["daemon_id", "operation"]
    },
    history: {
      data: ["daemon_id", "start", "end", "param"]
    }
  },
  "in": {
    loginCheck: {
      data: ["status"],
      processCallback: function(data) {
        return processLoginCheck(data);
      }
    },
    login: {
      data: ["session_id"],
      processCallback: function(data) {
        return processLogin(data);
      }
    },
    logout: {
      data: ["status"],
      processCallback: function(data) {
        return processLogout(data);
      }
    },
    daemons: {
      data: ["daemon_id", "daemon_name", "daemon_state", "daemon_address", "daemon_port", "daemon_platform", "daemon_all_parameters", "daemon_monitored_parameters"],
      processCallback: function(data) {
        return processDaemons(data);
      }
    },
    control: {
      data: ["daemon_id", "status", "operation"],
      processCallback: function(data) {
        return processControl(data);
      }
    },
    monitoring: {
      data: ["daemon_id", "data"],
      processCallback: function(data) {
        return processMonitoring(data);
      }
    },
    history: {
      data: ["daemon_id", "start", "end", "param", "point_distance", "points"],
      processCallback: function(data) {
        return processHistory(data);
      }
    },
    not_implemented: {
      data: [],
      processCallback: function(data) {
        return processNotImplemented(data);
      }
    },
    error: {
      data: [],
      processCallback: function(data) {
        return processError(data);
      }
    }
  }
};

processIncomingMessage = function(msg, from, messageEvent) {
  var data, message, type;
  console.log("Incoming message: " + msg);
  message = JSON.parse(msg);
  type = message.type;
  if (messages["in"][type]) {
    data = message.data;
    if (checkData(type, data, "in")) {
      return messages["in"][type].processCallback(data);
    }
  } else {
    return console.error("Received a message of unknown type");
  }
};

checkData = function(type, data, direction) {
  var daemon, dataTemplate, key, keyname, message, _i, _len;
  dataTemplate = messages[direction][type].data;
  for (key in dataTemplate) {
    if (!__hasProp.call(dataTemplate, key)) continue;
    keyname = dataTemplate[key];
    if (type === "daemons" && (direction = "in")) {
      if (data) {
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          daemon = data[_i];
          if (!daemon.hasOwnProperty(keyname)) {
            console.error("Wrong data format");
            return false;
          }
        }
      } else {
        console.error("Wrong data format");
        return false;
      }
    } else {
      if (data) {
        if (!data.hasOwnProperty(keyname)) {
          console.error("Wrong data format");
          return false;
        }
      } else {
        console.error("Wrong data format");
        return false;
      }
    }
  }
  if (direction === "out") {
    message = {
      type: type,
      data: data
    };
    return message;
  } else if (direction === "in") {
    return true;
  } else {
    return console.error("wrong direction");
  }
};

processLoginCheck = function(data) {
  var status;
  status = data.status;
  switch (status) {
    case "OK":
      console.log("You are logged in");
      return loginCheckSuccessful();
    case "UNAUTHORIZED":
      console.log("You are not logged in");
      return loginCheckUnsuccessful();
  }
};

processLogin = function(data) {
  var session_id;
  session_id = data.session_id;
  if (session_id) {
    console.log("You have successfully logged in (" + session_id + ")");
    return loginSuccessful(session_id);
  } else {
    console.log("Username or password are incorrect. Please log in");
    return loginUnsuccessful(session_id);
  }
};

processLogout = function(data) {
  var status;
  status = data.status;
  switch (status) {
    case "OK":
      console.log("You are no longer logged in");
      return logoutSuccessful();
    case "NOT_OK":
      console.log("Sorry, an error has occured");
      return logoutError();
  }
};

processDaemons = function(data) {
  var daemon, daemon_address, daemon_all_parameters, daemon_id, daemon_monitored_parameters, daemon_name, daemon_platform, daemon_port, daemon_state, key, param, str, value, _i, _j, _k, _len, _len1, _len2;
  for (_i = 0, _len = data.length; _i < _len; _i++) {
    daemon = data[_i];
    daemon_id = daemon.daemon_id;
    daemon_name = daemon.daemon_name;
    daemon_state = daemon.daemon_state;
    daemon_address = data.daemon_address;
    daemon_port = data.daemon_port;
    daemon_platform = data.daemon_platform;
    daemon_all_parameters = data.daemon_all_parameters;
    daemon_monitored_parameters = data.daemon_monitored_parameters;
    str = "";
    for (key in daemon_platform) {
      if (!__hasProp.call(daemon_platform, key)) continue;
      value = daemon_platform[key];
      str += key + ": " + value + "; ";
    }
    str += " ALL PARAMS: ";
    for (_j = 0, _len1 = daemon_all_parameters.length; _j < _len1; _j++) {
      param = daemon_all_parameters[_j];
      str += param + ", ";
    }
    str += " MON PARAMS: ";
    for (_k = 0, _len2 = daemon_monitored_parameters.length; _k < _len2; _k++) {
      param = daemon_monitored_parameters[_k];
      str += param + ", ";
    }
    console.log("ID " + daemon_id + "; Name " + daemon_name + "; State " + daemon_state + "; address " + daemon_address + "; port " + daemon_port + ". " + str);
  }
  return updateDaemons(data);
};

processControl = function(data) {
  var daemon_id, status;
  daemon_id = data.daemon_id;
  status = data.status;
  console.log("Control for daemon " + daemon_id + " was " + status);
  return controlStatus(data);
};

processMonitoring = function(data) {
  var daemon_id, key, mon, str, value;
  daemon_id = data.daemon_id;
  mon = data.data;
  str = "";
  for (key in mon) {
    if (!__hasProp.call(mon, key)) continue;
    value = mon[key];
    str += key + ": " + value + "; ";
  }
  console.log("Monitoring for " + daemon_id + ". " + str);
  return monitoringData(data);
};

processHistory = function(data) {
  var daemon_id, end, param, start;
  daemon_id = data.daemon_id;
  start = data.start;
  end = data.end;
  param = data.param;
  console.log("history for " + daemon_id + " param " + param + " for period from " + start + " to " + end);
  return processHistory(data);
};

processNotImplemented = function(data) {
  console.log("Not implemented: " + JSON.stringify(data));
  return notImplemented(data);
};

processError = function(data) {
  console.log("Not implemented: " + JSON.stringify(data));
  return error(data);
};

createMessage = function(type, data) {
  var message;
  message = checkData(type, data, "out");
  return message;
};

trySendMessage = function(msg, ws) {
  var message;
  try {
    message = JSON.stringify(msg);
    if (!ws) {
      serverws.send(message);
    } else {
      ws.send(message);
    }
    return console.log(msg.type + " message was sent " + message);
  } catch (err) {
    console.error(err);
    return false;
  } finally {
    return true;
  }
};

sendLoginCheck = function(session_id, ws) {
  var message;
  message = createMessage("loginCheck", {
    session_id: session_id
  });
  return trySendMessage(message, ws);
};

sendLogin = function(username, password) {
  var message;
  message = createMessage("login", {
    username: username,
    password: password
  });
  return trySendMessage(message);
};

sendLogout = function() {
  var message;
  message = createMessage("logout");
  return trySendMessage(message);
};

sendDaemons = function() {
  var message;
  message = createMessage("daemons");
  return trySendMessage(message);
};

sendControl = function(daemon_id, operation) {
  var message;
  message = createMessage("control", {
    daemon_id: daemon_id,
    operation: operation
  });
  return trySendMessage(message);
};

createServerWebSocket = function(address) {
  serverws = new WebSocket(serverAddress);
  serverws.onopen = wsServerOnOpenHandler;
  serverws.onclose = wsServerOnCloseHandler;
  serverws.onerror = wsServerOnErrorHandler;
  serverws.onmessage = wsServerOnMessageHandler;
  return serverws;
};

createDaemonWebSocket = function(address) {
  daemonAddress = address;
  daemonws = new WebSocket(address);
  daemonws.onopen = wsDaemonOnOpenHandler;
  daemonws.onclose = wsDaemonOnCloseHandler;
  daemonws.onerror = wsDaemonOnErrorHandler;
  daemonws.onmessage = wsDaemonOnMessageHandler;
  return daemonws;
};

wsServerOnOpenHandler = function() {
  console.log("Connection to the server is established.");
  if (reconnectTimerServer) {
    window.clearInterval(reconnectTimerServer);
    reconnectTimerServer = null;
  }
  if (!development) {
    return sendLoginCheck("123");
  } else if (testing) {
    return test();
  }
};

wsServerOnCloseHandler = function(event) {
  var wasClean;
  wasClean = event.wasClean;
  if (!wasClean) {
    console.log("Connection to the server (" + serverAddress + ") was lost unexpectedly. Re-connecting (" + reconnectTiming / 1000 + ")");
    if (!reconnectTimerServer) {
      return reconnectTimerServer = setInterval(function() {
        return serverws = createServerWebSocket(serverAddress);
      }, reconnectTiming);
    }
  } else {
    return console.log("Connection to the server was successfully closed.");
  }
};

wsServerOnErrorHandler = function(error) {
  return console.error("An error occured while talking to the server (" + serverAddress + ")");
};

wsServerOnMessageHandler = function(messageEvent) {
  return processIncomingMessage(messageEvent.data, messageEvent.target, messageEvent);
};

wsDaemonOnOpenHandler = function() {
  return sendLoginCheck("123", daemonws);
};

wsDaemonOnCloseHandler = function(event) {
  var wasClean;
  wasClean = event.wasClean;
  if (!wasClean) {
    console.log("Connection to the daemon was lost unexpectedly. Re-connecting (" + reconnectTiming / 1000 + ")");
    if (!reconnectTimerDaemon) {
      return reconnectTimerDaemon = setInterval(function() {
        return daemonws = createDaemonWebSocket(daemonAddress);
      }, reconnectTiming);
    }
  } else {
    return console.log("Connection to the daemon was successfully closed.");
  }
};

wsDaemonOnErrorHandler = function(error) {
  return console.error("An error occured while talking to the daemon");
};

wsDaemonOnMessageHandler = function(messageEvent) {
  return processIncomingMessage(messageEvent.data, messageEvent.target, messageEvent);
};

test = function() {
  var controlMessageNOTOK, controlMessageOK, daemonsMessage, errorMessage, loginCheckMessageOK, loginCheckMessageUNAUTHORIZED, loginMessageNOTNULL, loginMessageNULL, logoutMessageNOTOK, logoutMessageOK, monitoringMessage1, monitoringMessage2, monitoringMessage3, not_implementedMessage;
  if (testOUT) {
    console.log("OUTGOING TEST. DON'T PAY ATTENTION TO THE ERRORS - ECHO SERVER GIVES BACK BAD DATA (NOT BAD, BUT THE SAME)");
    sendLoginCheck("bla bla bla");
    sendLogin("foo", "bar");
    sendLogout();
    sendDaemons();
    sendControl("123123123", "DIE");
  }
  if (testIN) {
    console.log("INCOMING TEST");
    loginCheckMessageOK = {
      type: "loginCheck",
      data: {
        "status": "OK"
      }
    };
    trySendMessage(loginCheckMessageOK);
    loginCheckMessageUNAUTHORIZED = {
      type: "loginCheck",
      data: {
        "status": "UNAUTHORIZED"
      }
    };
    trySendMessage(loginCheckMessageUNAUTHORIZED);
    loginMessageNOTNULL = {
      type: "login",
      data: {
        "session_id": "123123123"
      }
    };
    trySendMessage(loginMessageNOTNULL);
    loginMessageNULL = {
      type: "login",
      data: {
        "session_id": null
      }
    };
    trySendMessage(loginMessageNULL);
    logoutMessageOK = {
      type: "logout",
      data: {
        "status": "OK"
      }
    };
    trySendMessage(logoutMessageOK);
    logoutMessageNOTOK = {
      type: "logout",
      data: {
        "status": "NOT_OK"
      }
    };
    trySendMessage(logoutMessageNOTOK);
    daemonsMessage = {
      type: "daemons",
      data: [
        {
          "daemon_id": "123",
          "daemon_name": "foo",
          "daemon_state": "RUNNING",
          "daemon_address": "123.123.123.123",
          "daemon_port": "666",
          "daemon_platform": {
            "OS": "Linux",
            "Architecture": "64 bit"
          },
          "daemon_all_parameters": ["CPU", "RAM", "HDD"],
          "daemon_monitored_parameters": ["CPU"]
        }, {
          "daemon_id": "234",
          "daemon_name": "bar",
          "daemon_state": "STOPPED",
          "daemon_address": "123.123.123.123",
          "daemon_port": "666",
          "daemon_platform": {
            "OS": "Linux",
            "Architecture": "64 bit"
          },
          "daemon_all_parameters": ["CPU", "RAM", "HDD"],
          "daemon_monitored_parameters": ["CPU"]
        }, {
          "daemon_id": "345",
          "daemon_name": "foobar",
          "daemon_state": "NOT_KNOWN",
          "daemon_address": "123.123.123.123",
          "daemon_port": "666",
          "daemon_platform": {
            "OS": "Linux",
            "Architecture": "64 bit"
          },
          "daemon_all_parameters": ["CPU", "RAM", "HDD"],
          "daemon_monitored_parameters": ["CPU"]
        }, {
          "daemon_id": "456",
          "daemon_name": "Bob",
          "daemon_state": "EATING A PIZZA",
          "daemon_address": "123.123.123.123",
          "daemon_port": "666",
          "daemon_platform": {
            "OS": "Linux",
            "Architecture": "64 bit"
          },
          "daemon_all_parameters": ["CPU", "RAM", "HDD"],
          "daemon_monitored_parameters": ["CPU"]
        }
      ]
    };
    trySendMessage(daemonsMessage);
    controlMessageOK = {
      type: "control",
      data: {
        "daemon_id": "123",
        "status": "OK",
        "operation": "KILL"
      }
    };
    trySendMessage(controlMessageOK);
    controlMessageNOTOK = {
      type: "control",
      data: {
        "daemon_id": "123",
        "status": "NOT_OK",
        "operation": {
          "start": ["CPU", "RAM"],
          "stop": ["NET"]
        }
      }
    };
    trySendMessage(controlMessageNOTOK);
    monitoringMessage1 = {
      type: "monitoring",
      data: {
        "daemon_id": "123",
        "data": {
          "CPU": "100",
          "RAM": "111"
        }
      }
    };
    trySendMessage(monitoringMessage1);
    monitoringMessage2 = {
      type: "monitoring",
      data: {
        "daemon_id": "234",
        "data": {
          "CPU": "50",
          "RAM": "222"
        }
      }
    };
    trySendMessage(monitoringMessage2);
    monitoringMessage3 = {
      type: "monitoring",
      data: {
        "daemon_id": "345",
        "data": {
          "CPU": "25",
          "RAM": "333"
        }
      }
    };
    trySendMessage(monitoringMessage3);
    not_implementedMessage = {
      type: "not_implemented",
      data: {
        "this": "is a wrong message"
      }
    };
    trySendMessage(not_implementedMessage);
    errorMessage = {
      type: "error",
      data: {
        "error": "error info"
      }
    };
    return trySendMessage(errorMessage);
  }
};

graphs = [];

graph_id = 0;

Graph = (function() {

  function Graph(daemon_id, type, params, location) {
    var i, labels, _i, _j, _ref, _ref1;
    graphs.push(this);
    this.daemon_id = daemon_id;
    this.type = type;
    this.graph_id = "gpaph_" + graph_id;
    graph_id++;
    this.canvas = "<canvas id='" + this.graph_id + "' width='400' height='400'></canvas>";
    if (!location) {
      location = $("#graphs");
    }
    location.append(this.canvas);
    this.ctx = ($("#" + this.graph_id).get(0)).getContext("2d");
    this.data = [];
    switch (type) {
      case "cpu":
        this.cpuCount = params.count;
        this.options = {
          animation: false,
          scaleOverride: true,
          scaleSteps: 10,
          scaleStepWidth: 10,
          scaleStartValue: 0
        };
        this.getGraph = function(data) {
          return new Chart(this.ctx).Bar(data, this.options);
        };
        labels = [];
        for (i = _i = 0, _ref = this.cpuCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          labels.push("CPU " + (i + 1));
        }
        this.data = {
          labels: labels,
          datasets: [
            {
              fillColor: "rgba(220,220,220,0.5)",
              strokeColor: "rgba(220,220,220,1)",
              data: []
            }
          ]
        };
        this.setData = function(data) {
          return this.data.datasets[0].data = data;
        };
        break;
      case "ram":
        this.totalRam = params.total;
        this.options = {
          animation: false,
          scaleOverride: true,
          scaleSteps: this.totalRam / 256,
          scaleStepWidth: 256,
          scaleStartValue: 0
        };
        this.getGraph = function(data) {
          return new Chart(this.ctx).Bar(data, this.options);
        };
        labels = ["RAM"];
        this.data = {
          labels: labels,
          datasets: [
            {
              fillColor: "rgba(220,220,220,0.5)",
              strokeColor: "rgba(220,220,220,1)",
              data: []
            }
          ]
        };
        this.setData = function(data) {
          return this.data.datasets[0].data = [data];
        };
        break;
      case "karma":
        this.pointNumber = 10;
        this.lastPoints = new Array(this.pointNumber);
        for (i = _j = 0, _ref1 = this.pointNumber; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          this.lastPoints[i] = 0;
        }
        this.options = {
          animation: false,
          scaleOverride: true,
          scaleSteps: 10,
          scaleStepWidth: 10,
          scaleStartValue: 0
        };
        this.getGraph = function(data) {
          return new Chart(this.ctx).Line(data, this.options);
        };
        labels = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        this.data = {
          labels: labels,
          datasets: [
            {
              fillColor: "rgba(220,220,220,0.5)",
              strokeColor: "rgba(220,220,220,1)",
              data: []
            }
          ]
        };
        this.setData = function(data) {
          var _k, _ref2;
          for (i = _k = 1, _ref2 = this.pointNumber; 1 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 1 <= _ref2 ? ++_k : --_k) {
            this.lastPoints[i - 1] = this.lastPoints[i];
          }
          this.lastPoints[this.pointNumber - 1] = data;
          return this.data.datasets[0].data = this.lastPoints;
        };
    }
  }

  Graph.prototype.create = function(data) {
    this.setData(data);
    return this.getGraph(this.data);
  };

  Graph.prototype.show = function() {
    return $("#" + this.graph_id).show();
  };

  Graph.prototype.hide = function() {
    return $("#" + this.graph_id).hide();
  };

  Graph.prototype.update = function(data) {
    return this.create(data);
  };

  return Graph;

})();

getGraph = function(daemon_id, type) {
  var graph, _i, _len;
  for (_i = 0, _len = graphs.length; _i < _len; _i++) {
    graph = graphs[_i];
    if (graph.daemon_id === daemon_id && graph.type === type) {
      return graph;
    }
  }
};

simulate = function(timing) {
  var cpuGenerator1, cpuGenerator2, cpuGenerator3, cpuGenerator4, karmaGenerator, ramGenerator;
  new Graph("simulation", "karma");
  new Graph("simulation", "cpu", {
    count: 4
  });
  new Graph("simulation", "ram", {
    total: 2048
  });
  karmaGenerator = new SmoothRandomGenerator(100, 10);
  cpuGenerator1 = new SmoothRandomGenerator(100, 10);
  cpuGenerator2 = new SmoothRandomGenerator(100, 10);
  cpuGenerator3 = new SmoothRandomGenerator(100, 10);
  cpuGenerator4 = new SmoothRandomGenerator(100, 10);
  ramGenerator = new SmoothRandomGenerator(2048, 10);
  return setInterval(function() {
    var karmaMessage;
    karmaMessage = {
      type: "monitoring",
      data: {
        "daemon_id": "simulation",
        "data": {
          "karma": karmaGenerator.getNumber(),
          "cpu": [cpuGenerator1.getNumber(), cpuGenerator2.getNumber(), cpuGenerator3.getNumber(), cpuGenerator4.getNumber()],
          "ram": ramGenerator.getNumber()
        }
      }
    };
    return trySendMessage(karmaMessage);
  }, timing);
};

SmoothRandomGenerator = (function() {

  function SmoothRandomGenerator(max, diff) {
    this.max = max;
    this.current = max / 2;
    this.diff = diff;
  }

  SmoothRandomGenerator.prototype.getNumber = function() {
    this.current += (Math.random() > 0.5 ? 1 : -1) * (Math.random() * this.max + 1) / this.diff;
    if (this.current > this.max) {
      this.current = this.max;
    }
    if (this.current < 0) {
      this.current = 0;
    }
    return Math.floor(this.current);
  };

  SmoothRandomGenerator.prototype.getNumbers = function(n) {
    var i, numbers, _i;
    numbers = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      numbers.push(this.getNumber());
    }
    return numbers;
  };

  return SmoothRandomGenerator;

})();

simulate2 = function(address) {
  daemonAddress = address;
  new Graph("12345", "cpu", {
    count: 1
  });
  return daemonws = createDaemonWebSocket(daemonAddress);
};
